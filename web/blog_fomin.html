<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c3{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c1{orphans:2;widows:2}.c2{height:11pt}.c0{font-weight:bold}.title{padding-top:0pt;color:#000000;font-size:21pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:13pt;padding-bottom:10pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:10pt;color:#000000;font-size:16pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:10pt;color:#000000;font-weight:bold;font-size:13pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:8pt;color:#666666;font-weight:bold;font-size:12pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:8pt;color:#666666;text-decoration:underline;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c3"><p class="c1"><span class="c0">MIAApplicationController.cpp Excerpt</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>// Clears the stacks when a new directory image is reloaded.</span></p><p class="c1"><span>void MIAApplicationController::clearStacks()</span></p><p class="c1"><span>{</span></p><p class="c1"><span>&nbsp; &nbsp; while (!previousStack.empty())</span></p><p class="c1"><span>&nbsp; &nbsp; {</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; previousStack.pop();</span></p><p class="c1"><span>&nbsp; &nbsp; }</span></p><p class="c1"><span>&nbsp; &nbsp; while (!nextStack.empty())</span></p><p class="c1"><span>&nbsp; &nbsp; {</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; nextStack.pop();</span></p><p class="c1"><span>&nbsp; &nbsp; }</span></p><p class="c1"><span>}</span></p><p class="c1"><span>// Event Callback that handles stack setup for image in the flipper directory.</span></p><p class="c1"><span>void MIAApplicationController::loadFlipperImage()</span></p><p class="c1"><span>{</span></p><p class="c1"><span>&nbsp; &nbsp; clearStacks();</span></p><p class="c1"><span>}</span></p><p class="c1"><span>// Cycles to the next image in the flipper stack if it exists, returning a PixelBuffer representation.</span></p><p class="c1"><span>PixelBuffer* MIAApplicationController::nextImage()</span></p><p class="c1"><span>{</span></p><p class="c1"><span>&nbsp; &nbsp; PixelBuffer* aSavePixelBuffer = new PixelBuffer(m_currentCanvas-&gt;getWidth(), m_currentCanvas-&gt;getHeight(), new ColorData(0,0,0));</span></p><p class="c1"><span>&nbsp; &nbsp; PixelBuffer::copyPixelBuffer(m_currentCanvas, aSavePixelBuffer);</span></p><p class="c1"><span>&nbsp; &nbsp; previousStack.push(aSavePixelBuffer);</span></p><p class="c1"><span>&nbsp; &nbsp; if (!nextStack.empty())</span></p><p class="c1"><span>&nbsp; &nbsp; {</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; PixelBuffer* buffer = NULL;</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; buffer = nextStack.top();</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; nextStack.pop();</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; changeBuffer(buffer);</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; return buffer;</span></p><p class="c1"><span>&nbsp; &nbsp; } else {</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; return NULL;</span></p><p class="c1"><span>&nbsp; &nbsp; }</span></p><p class="c1"><span>}</span></p><p class="c1"><span>// Cycles to the previous image in the flipper stack if it exists, returning a PixelBuffer representation.</span></p><p class="c1"><span>PixelBuffer* MIAApplicationController::previousImage()</span></p><p class="c1"><span>{</span></p><p class="c1"><span>&nbsp; &nbsp; PixelBuffer* aSavePixelBuffer = new PixelBuffer(m_currentCanvas-&gt;getWidth(), m_currentCanvas-&gt;getHeight(), new ColorData(0,0,0));</span></p><p class="c1"><span>&nbsp; &nbsp; PixelBuffer::copyPixelBuffer(m_currentCanvas, aSavePixelBuffer);</span></p><p class="c1"><span>&nbsp; &nbsp; nextStack.push(aSavePixelBuffer);</span></p><p class="c1"><span>&nbsp; &nbsp; if (!previousStack.empty())</span></p><p class="c1"><span>&nbsp; &nbsp; {</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; PixelBuffer* buffer = NULL;</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; buffer = previousStack.top();</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; previousStack.pop();</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; changeBuffer(buffer);</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; return buffer;</span></p><p class="c1"><span>&nbsp; &nbsp; } else {</span></p><p class="c1"><span>&nbsp; &nbsp; &nbsp; &nbsp; return NULL;</span></p><p class="c1"><span>&nbsp; &nbsp; }</span></p><p class="c1"><span>}</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span>One design decision that I was personally responsible for was the implementation of the 3D Image Viewing system.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Purpose</span></p><p class="c1 c2"><span></span></p><p class="c1"><span>The necessity of a 3D viewing system is outlined clearly in the project description. It allows for the quick cycling on images in a numerical series stored in a common directly quickly and efficiently with the use of the previous and next image buttons. It was decided by our team that this system would also be able to track any changes made to the flipped images while they are present in the user interface so that flipping between them is a safe operation.</span></p><p class="c1 c2"><span></span></p><p class="c1 c2"><span></span></p><p class="c1"><span class="c0">Implementation and Style</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Since this functionality is so integral to the operation and GUI of the program, it was decided that the 3D viewing capabilities and events would become a part of the MIAApplicationController class. The flipper would receive a dual-stack implementation similar to the Undo/Redo stacks to track any user changes with the MIA application is open. Upon a next image flip, a new canvas is pushed to the previous stack and vice versa. When next or previous image is clicked, first the previous and next stacks are checked for the possibility of user changes, if they do not exist, then the original image is simply loaded. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Documentation</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Much of the code in this snippet is self documenting, the use of the dual-stack structure is very intuitive and can be visualized pictorial with moving frames between two stacks. The documentation that does exist explains more thoroughly the operations and purposes of the two stacks. Additionally, it explains when the stacks&rsquo; PixelBuffers will be used instead of simply the original loaded image.</span></p><p class="c1 c2"><span></span></p></body></html>